package duke;

import duke.commands.*;
import duke.task.Deadline;
import duke.task.Event;
import duke.task.Task;
import duke.task.ToDo;
import duke.task.TaskList;

import java.util.ArrayList;
import java.util.Scanner;

public class Parser {
    private static final String BYE_COMMAND = "bye";
    private static final String LIST_COMMAND = "list";
    private static final String TODO_COMMAND = "todo";
    private static final String DEADLINE_COMMAND = "deadline";
    private static final String EVENT_COMMAND = "event";
    private static final String DONE_COMMAND = "done";
    private static final String DELETE_COMMAND = "delete";
    private static final String FIND_COMMAND = "find";


    /**
     * Returns a Task object that is generated by converting the string representation
     * of the Task object read from the storage file.
     *
     * @param taskInString the string representation of the Task object
     * @return a Task object generated from the its string representation
     */
    public static Task decodeTaskData(String taskInString) {
        try {
            String[] splitTaskStringArr = taskInString.split("[|]");
            String taskType = splitTaskStringArr[0].trim();
            String description = splitTaskStringArr[2].trim();
            boolean isDone = splitTaskStringArr[1].trim().equals("\u2713");


            switch (taskType) {
                case "T":
                    ToDo todo = new ToDo(description);
                    if (isDone) {
                        todo.markAsDone();
                    }
                    return todo;
                case "D":
                    String taskDeadline = splitTaskStringArr[3].trim();
                    Deadline deadline = new Deadline(description, taskDeadline);
                    if (isDone) {
                        deadline.markAsDone();
                    }
                    return deadline;
                case "E":
                    String eventDateTime = splitTaskStringArr[3].trim();
                    Event event = new Event(description, eventDateTime);
                    if (isDone) {
                        event.markAsDone();
                    }
                    return event;
                default:
                    return null;
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            return null;
        }
    }


    /**
     * Reads and processes the user input.
     *
     * @throws DukeException if the user provided an invalid input.
     */
    public static void readUserInput() throws DukeException {
        Scanner in = new Scanner(System.in);
        String userInput;
        do {
            userInput = in.nextLine();
            ArrayList<String> inputArguments = parseUserInput(userInput);
            runCommand(inputArguments);
        } while (!userInput.equalsIgnoreCase("bye"));
    }

    /**
     * Parses and processes the user input to generate command.
     *
     * @throws DukeException if the user provided an invalid input.
     */
    private static ArrayList<String> parseUserInput(String data) throws DukeException {

        ArrayList<String> userArgs = new ArrayList<>();
        String[] userArgsArray = data.split(" ");

        try{
            for (String arg : userArgsArray) {
                userArgs.add(arg.trim());
            }
        } catch (ArrayIndexOutOfBoundsException exception) {
            throw new DukeException("Duke cannot read this: " + data);
        }

        return userArgs;
    }

    /**
     * Process input into commands.
     *
     * @throws DukeException if there is no valid input.
     */
    private static void runCommand(ArrayList<String> inputArguments) throws DukeException {
        String userCommand = inputArguments.get(0);
        switch (userCommand) {
        case BYE_COMMAND:
            new ByeCommand();
            break;
        case LIST_COMMAND:
            new ListCommand();
            break;
        case DONE_COMMAND:
            new DoneCommand(inputArguments);
            break;
        case DELETE_COMMAND:
            new DeleteCommand(inputArguments);
            break;
        case FIND_COMMAND:
            new FindCommand(inputArguments);
            break;
        case TODO_COMMAND:
            new ToDoCommand(inputArguments);
            break;
        case DEADLINE_COMMAND:
            new DeadlineCommand(inputArguments);
            break;
        case EVENT_COMMAND:
            new EventCommand(inputArguments);
            break;
        default:
            throw new DukeException(" Command \"" + userCommand + "\" is not a valid command. :(");
        }
    }

}